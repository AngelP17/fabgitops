# FabGitOps: The Master File

> **The Infrastructure Layer** of the Industrial Cloud Stack  
> **Status:** Production-Ready (Includes CI/CD & Helm)  
> **Stack:** Rust, Kubernetes, Helm, GitHub Actions, Prometheus

---

## Part 1: The Super Prompt

Copy and paste the section below into your AI coding assistant (Claude 3.5 Sonnet, GPT-4o, Cursor) to kickstart the project context.

### ACT AS:

A Staff Platform Engineer at a major industrial tech company (like Intel, Siemens, or Rockwell). You specialize in "Industrial DevOps," building Internal Developer Platforms (IDP), and strictly adhere to GitOps principles.

### THE PROJECT:

I am building **"FabGitOps"** to complete my portfolio for a role at Intel's EC Infra team.

- This is the **"Infrastructure Layer"** of my Industrial Cloud Stack.
- **The Goal:** A Kubernetes Operator (Rust) that manages industrial PLCs, paired with a **developer-grade CLI** and **Prometheus metrics**.
- **Constraint:** NO WEB UI. The interface must be purely terminal-based (CLI) and industry-standard observability tools (Grafana).

### THE STACK:

- **Core:** Rust (2021), `kube-rs` (Operator SDK), `tokio` (Async).
- **CLI:** `clap` (Command Line Argument Parser), `colored` (Terminal colors), `tabled` (Pretty tables).
- **Observability:** `prometheus` (Metrics), `grafana` (Visualization).
- **Packaging & CI:** Helm 3, GitHub Actions, Docker.
- **Protocol:** Modbus TCP (simulated).

### YOUR TASK:

Guide me step-by-step to build this "Headless" Platform Tool, from code to production pipeline.

#### Phase 1: The Core Operator (Rust)

- Define the `IndustrialPLC` CRD with fields for `target_register` and `target_value`.
- Implement the Reconciliation Loop: Watch K8s -> Compare with Mock Device -> Fix Drift.
- Use `thiserror` for idiomatic error handling.

#### Phase 2: The "Chaos" Simulator

- Create a standalone binary `mock-plc` that listens on a port.
- **Feature:** It must have a "Chaos Mode" where it randomly changes its own values every 10s to simulate hardware drift.

#### Phase 3: The "fabctl" CLI Tool

- Create a binary `fabctl` using `clap`.
- **Command 1:** `fabctl get-status` -> Connects to K8s, fetches the CRD status, and prints a beautiful ASCII table showing "Git vs. Reality."
- **Command 2:** `fabctl sync --force` -> Manually triggers a reconciliation event (by annotating the resource).

#### Phase 4: The Observability Stack

- Instrument the operator to expose a `/metrics` endpoint.
- **Metric:** `drift_events_total` (Counter) - increments every time the operator has to fix the PLC.
- Provide a `docker-compose.yaml` to spin up Prometheus (scraping localhost:9090) and Grafana.

#### Phase 5: The Demo Script

- **"The Terminal Dashboard":** show me how to use `watch -n 1 fabctl get-status` to create a live-updating terminal view.
- **The Flow:** Start the Chaos PLC -> Watch `fabctl` show "Drift" -> Watch Grafana graph spike -> Watch Operator fix it -> System returns to Green.

#### Phase 6: The "Production-Ready" Pipeline (CI/CD)

##### Task A: Helm Packaging

- Create a real Helm Chart (`charts/fabgitops`) that templates the deployment.
- Include `values.yaml` for configuring the Operator image and PLC polling intervals.
- **Why?** Because Intel uses Helm, not raw YAML.

##### Task B: GitHub Actions Workflow (`.github/workflows/ci.yaml`)

Write a workflow that:

1. **Lints & Tests:** Runs `cargo fmt --check`, `cargo clippy`, and `cargo test`.
2. **Builds & Publishes:** Builds the Docker image and pushes it to GitHub Container Registry (`ghcr.io`).
3. **End-to-End Test (The "Staff Flex"):** Spins up a ephemeral `kind` cluster, installs the operator via Helm, creates a Mock PLC, and verifies the "Running" status.

##### Task C: Architecture Decision Records (ADRs)

Generate two ADR markdown files in `docs/adr/`:

- `001-why-rust-operator.md`: Why we chose Rust over Go (Safety, No GC pauses).
- `002-modbus-tcp-strategy.md`: Why we used polling vs interrupts (Legacy hardware limits).

### START:

Verify you understand the "Production" scope (including CI/CD and Helm), and outline the Cargo workspace structure.

---

## Part 2: Complete Project Implementation

This section contains the actual code and configuration files generated by the prompt above.

---

## Table of Contents

1. [Project Overview](#1-project-overview)
2. [Project Structure](#2-project-structure)
3. [Phase 1: Core Operator](#3-phase-1-the-core-operator-rust)
4. [Phase 2: Chaos Simulator](#4-phase-2-the-chaos-simulator)
5. [Phase 3: fabctl CLI Tool](#5-phase-3-the-fabctl-cli-tool)
6. [Phase 4: Observability Stack](#6-phase-4-the-observability-stack)
7. [Phase 5: Demo & Deployment](#7-phase-5-demo--deployment)
8. [Phase 6: Production Pipeline (CI/CD)](#8-phase-6-production-pipeline-cicd)
9. [Interview Talking Points](#9-interview-talking-points)
10. [Quick Start (Production Mode)](#10-quick-start-production-mode)

---

## 1. Project Overview

### The "Triple Threat" Portfolio Stack

| Project | **FactoryOps** | **ForgeMesh** | **FabGitOps** |
|---------|---------------|---------------|---------------|
| **The Layer** | **Presentation Layer** | **Data Layer** | **Infrastructure Layer** |
| **The Audience** | *Factory Managers* | *Software Architects* | *DevOps/SRE Engineers* |
| **The Interface** | **Web UI** (Next.js/React) | **API / P2P Mesh** (Backend) | **CLI Tool** (`fabctl`) & **Grafana** |
| **Key Skill** | "I can make it easy to use." | "I can handle complex data." | **"I can automate the platform."** |
| **The "Vibe"** | Polished, User-Centric | Complex, Algorithmic | **Robust, Utilities-Focused** |

### Why CLI + Metrics Over Web UI?

- **Internal Tooling**: Building `fabctl` proves you can build tools for *other developers*, not just end-users
- **Observability Engineering**: Shows you understand industry standards (Prometheus) rather than just custom JavaScript
- **Infrastructure-as-Code**: You're building the thing that *manages* deployments

**Interview Moment**: *Open the terminal. "Look how I control a global fleet of devices with one command."*

---

## 2. Project Structure

### Cargo Workspace Layout

```
fabgitops/
â”œâ”€â”€ Cargo.toml                    # Workspace root
â”œâ”€â”€ README.md
â”œâ”€â”€ docker-compose.yml            # Prometheus + Grafana
â”œâ”€â”€ prometheus.yml                # Prometheus config
â”‚
â”œâ”€â”€ charts/                       # [NEW] Helm Chart (Phase 6)
â”‚   â””â”€â”€ fabgitops/
â”‚       â”œâ”€â”€ Chart.yaml
â”‚       â”œâ”€â”€ values.yaml
â”‚       â””â”€â”€ templates/
â”‚           â”œâ”€â”€ deployment.yaml
â”‚           â”œâ”€â”€ _helpers.tpl
â”‚           â”œâ”€â”€ rbac.yaml
â”‚           â””â”€â”€ service.yaml
â”‚
â”œâ”€â”€ .github/                      # [NEW] CI/CD (Phase 6)
â”‚   â””â”€â”€ workflows/
â”‚       â””â”€â”€ ci.yaml
â”‚
â”œâ”€â”€ docs/                         # [NEW] Documentation (Phase 6)
â”‚   â””â”€â”€ adr/
â”‚       â”œâ”€â”€ 001-why-rust-operator.md
â”‚       â””â”€â”€ 002-modbus-tcp-strategy.md
â”‚
â”œâ”€â”€ crates/
â”‚   â”œâ”€â”€ operator/                 # Kubernetes Operator (Rust)
â”‚   â”‚   â”œâ”€â”€ Cargo.toml
â”‚   â”‚   â””â”€â”€ src/
â”‚   â”‚       â”œâ”€â”€ main.rs
â”‚   â”‚       â”œâ”€â”€ crd.rs           # IndustrialPLC CRD
â”‚   â”‚       â”œâ”€â”€ controller.rs    # Reconciliation loop
â”‚   â”‚       â”œâ”€â”€ metrics.rs       # Prometheus metrics
â”‚   â”‚       â””â”€â”€ plc_client.rs    # Modbus client
â”‚   â”‚
â”‚   â”œâ”€â”€ fabctl/                   # CLI Tool
â”‚   â”‚   â”œâ”€â”€ Cargo.toml
â”‚   â”‚   â””â”€â”€ src/
â”‚   â”‚       â”œâ”€â”€ main.rs
â”‚   â”‚       â”œâ”€â”€ commands.rs      # CLI commands
â”‚   â”‚       â”œâ”€â”€ output.rs        # Pretty table formatting
â”‚   â”‚       â””â”€â”€ k8s_client.rs    # Kubernetes client
â”‚   â”‚
â”‚   â””â”€â”€ mock-plc/                 # Chaos Simulator
â”‚       â”œâ”€â”€ Cargo.toml
â”‚       â””â”€â”€ src/
â”‚           â”œâ”€â”€ main.rs
â”‚           â”œâ”€â”€ server.rs        # Modbus server
â”‚           â””â”€â”€ chaos.rs         # Chaos mode
â”‚
â”œâ”€â”€ k8s/                          # Raw K8s manifests (for dev)
â”‚   â”œâ”€â”€ crd.yaml
â”‚   â”œâ”€â”€ rbac.yaml
â”‚   â”œâ”€â”€ deployment.yaml
â”‚   â””â”€â”€ sample-plc.yaml
â”‚
â””â”€â”€ Dockerfile.operator           # Docker build
```

### Root Cargo.toml

```toml
[workspace]
resolver = "2"
members = [
    "crates/operator",
    "crates/fabctl",
    "crates/mock-plc",
]

[workspace.dependencies]
tokio = { version = "1.35", features = ["full"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
serde_yaml = "0.9"
anyhow = "1.0"
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter"] }
```

---

## 3. Phase 1: The Core Operator (Rust)

### 3.1 Operator Cargo.toml

```toml
[package]
name = "operator"
version = "0.1.0"
edition = "2021"

[dependencies]
kube = { version = "0.87", features = ["runtime", "derive"] }
k8s-openapi = { version = "0.20", features = ["v1_28"] }
tokio = { workspace = true }
serde = { workspace = true }
serde_json = { workspace = true }
anyhow = { workspace = true }
thiserror = "1.0"
tracing = { workspace = true }
tracing-subscriber = { workspace = true }
prometheus = "0.13"
axum = "0.7"
tokio-modbus = { version = "0.9", default-features = false, features = ["tcp"] }
schemars = "0.8"
futures = "0.3"
chrono = "0.4"
```

### 3.2 CRD Definition - `crates/operator/src/crd.rs`

```rust
use kube::CustomResource;
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};

#[derive(CustomResource, Clone, Debug, Deserialize, Serialize, JsonSchema)]
#[kube(
    group = "fabgitops.io",
    version = "v1",
    kind = "IndustrialPLC",
    plural = "industrialplcs",
    shortname = "plc",
    namespaced,
    status = "IndustrialPLCStatus"
)]
#[serde(rename_all = "camelCase")]
pub struct IndustrialPLCSpec {
    pub device_address: String,
    #[serde(default = "default_port")]
    pub port: u16,
    pub target_register: u16,
    pub target_value: u16,
    #[serde(default = "default_interval")]
    pub poll_interval_secs: u64,
    #[serde(default = "default_auto_correct")]
    pub auto_correct: bool,
    #[serde(default)]
    pub tags: Vec<String>,
}

fn default_port() -> u16 { 502 }
fn default_interval() -> u64 { 5 }
fn default_auto_correct() -> bool { true }

#[derive(Clone, Debug, Deserialize, Serialize, JsonSchema, Default)]
#[serde(rename_all = "camelCase")]
pub struct IndustrialPLCStatus {
    pub phase: PLCPhase,
    pub last_update: Option<String>,
    pub current_value: Option<u16>,
    pub in_sync: bool,
    pub drift_events: u32,
    pub corrections_applied: u32,
    pub last_error: Option<String>,
    pub message: String,
}

#[derive(Clone, Debug, Deserialize, Serialize, JsonSchema, Default, PartialEq)]
#[serde(rename_all = "PascalCase")]
pub enum PLCPhase {
    #[default]
    Pending,
    Connecting,
    Connected,
    DriftDetected,
    Correcting,
    Failed,
}

impl IndustrialPLCStatus {
    pub fn new() -> Self {
        Self {
            phase: PLCPhase::Pending,
            message: "Initializing...".to_string(),
            ..Default::default()
        }
    }
}
```

### 3.3 Metrics - `crates/operator/src/metrics.rs`

```rust
use prometheus::{Counter, Gauge, Registry, Opts};
use std::sync::Arc;

#[derive(Clone)]
pub struct OperatorMetrics {
    pub registry: Registry,
    pub drift_events_total: Counter,
    pub corrections_total: Counter,
    pub managed_plcs: Gauge,
    pub reconciliation_duration: Gauge,
    pub plc_connection_status: Gauge,
    pub register_value: Gauge,
}

impl OperatorMetrics {
    pub fn new() -> anyhow::Result<Self> {
        let registry = Registry::new();
        let drift_events_total = Counter::with_opts(
            Opts::new("drift_events_total", "Total drift events")
        )?;
        let corrections_total = Counter::with_opts(
            Opts::new("corrections_total", "Total corrections")
        )?;
        let managed_plcs = Gauge::with_opts(
            Opts::new("managed_plcs", "Managed PLCs count")
        )?;
        let reconciliation_duration = Gauge::with_opts(
            Opts::new("reconciliation_duration_seconds", "Reconciliation duration")
        )?;
        let plc_connection_status = Gauge::with_opts(
            Opts::new("plc_connection_status", "PLC connection status")
        )?;
        let register_value = Gauge::with_opts(
            Opts::new("register_value", "Current register value")
        )?;
        
        registry.register(Box::new(drift_events_total.clone()))?;
        registry.register(Box::new(corrections_total.clone()))?;
        registry.register(Box::new(managed_plcs.clone()))?;
        registry.register(Box::new(reconciliation_duration.clone()))?;
        registry.register(Box::new(plc_connection_status.clone()))?;
        registry.register(Box::new(register_value.clone()))?;
        
        Ok(Self { registry, drift_events_total, corrections_total, managed_plcs, reconciliation_duration, plc_connection_status, register_value })
    }
    
    pub fn record_drift(&self) { self.drift_events_total.inc(); }
    pub fn record_correction(&self) { self.corrections_total.inc(); }
    pub fn set_managed_plcs(&self, count: i64) { self.managed_plcs.set(count as f64); }
    pub fn set_connection_status(&self, connected: bool) { self.plc_connection_status.set(if connected { 1.0 } else { 0.0 }); }
    pub fn set_register_value(&self, value: u16) { self.register_value.set(value as f64); }
}

impl Default for OperatorMetrics {
    fn default() -> Self { Self::new().expect("Failed to create metrics") }
}
```

### 3.4 PLC Client - `crates/operator/src/plc_client.rs`

```rust
use tokio::net::TcpStream;
use tokio_modbus::prelude::*;
use anyhow::{Result, Context};

pub struct PLCClient {
    address: String,
    port: u16,
}

impl PLCClient {
    pub fn new(address: impl Into<String>, port: u16) -> Self {
        Self { address: address.into(), port }
    }
    
    pub async fn read_register(&self, register: u16) -> Result<u16> {
        let socket_addr = format!("{}:{}", self.address, self.port).parse()
            .context("Invalid PLC address")?;
        let stream = TcpStream::connect(socket_addr).await
            .context("Failed to connect to PLC")?;
        let mut ctx = tcp::attach(stream);
        let response = ctx.read_holding_registers(register, 1).await
            .context("Failed to read register")?;
        ctx.disconnect().await.ok();
        response.get(0).copied().context("Empty response from PLC")
    }
    
    pub async fn write_register(&self, register: u16, value: u16) -> Result<()> {
        let socket_addr = format!("{}:{}", self.address, self.port).parse()
            .context("Invalid PLC address")?;
        let stream = TcpStream::connect(socket_addr).await
            .context("Failed to connect to PLC")?;
        let mut ctx = tcp::attach(stream);
        ctx.write_single_register(register, value).await
            .context("Failed to write register")?;
        ctx.disconnect().await.ok();
        Ok(())
    }
    
    pub async fn health_check(&self) -> Result<bool> {
        match TcpStream::connect(format!("{}:{}", self.address, self.port)).await {
            Ok(_) => Ok(true),
            Err(_) => Ok(false),
        }
    }
}
```

### 3.5 Controller - `crates/operator/src/controller.rs`

```rust
use crate::crd::{IndustrialPLC, IndustrialPLCStatus, PLCPhase};
use crate::metrics::OperatorMetrics;
use crate::plc_client::PLCClient;
use kube::api::{Api, Patch, PatchParams};
use kube::runtime::controller::{Action, Controller};
use kube::runtime::events::{Event, EventType, Recorder, Reporter};
use kube::Client;
use std::sync::Arc;
use std::time::Duration;
use tokio::time::Instant;
use tracing::{error, info};

#[derive(Clone)]
pub struct Context {
    pub client: Client,
    pub metrics: Arc<OperatorMetrics>,
    pub reporter: Reporter,
}

pub async fn reconcile(plc: Arc<IndustrialPLC>, ctx: Arc<Context>) -> Result<Action, Error> {
    let start = Instant::now();
    let name = plc.name_any();
    let namespace = plc.namespace().unwrap_or_default();
    info!("Reconciling PLC: {}/{}", namespace, name);
    
    let api: Api<IndustrialPLC> = Api::namespaced(ctx.client.clone(), &namespace);
    let mut status = IndustrialPLCStatus::new();
    let plc_client = PLCClient::new(&plc.spec.device_address, plc.spec.port);
    
    match plc_client.health_check().await {
        Ok(true) => ctx.metrics.set_connection_status(true),
        Ok(false) | Err(_) => {
            ctx.metrics.set_connection_status(false);
            status.set_error("PLC unreachable".to_string());
            update_status(&api, &name, status).await?;
            return Ok(Action::requeue(Duration::from_secs(10)));
        }
    }
    
    match plc_client.read_register(plc.spec.target_register).await {
        Ok(current_value) => {
            ctx.metrics.set_register_value(current_value);
            if current_value != plc.spec.target_value {
                ctx.metrics.record_drift();
                status.set_drift(plc.spec.target_value, current_value);
                if plc.spec.auto_correct {
                    status.set_correcting();
                    update_status(&api, &name, status.clone()).await?;
                    match plc_client.write_register(plc.spec.target_register, plc.spec.target_value).await {
                        Ok(()) => {
                            ctx.metrics.record_correction();
                            status.set_corrected(plc.spec.target_value);
                        }
                        Err(e) => status.set_error(format!("Failed to correct: {}", e)),
                    }
                }
            } else {
                status.set_synced(current_value);
            }
        }
        Err(e) => status.set_error(format!("Failed to read register: {}", e)),
    }
    
    update_status(&api, &name, status).await?;
    let duration = start.elapsed().as_secs_f64();
    ctx.metrics.reconciliation_duration.set(duration);
    Ok(Action::requeue(Duration::from_secs(plc.spec.poll_interval_secs)))
}

async fn update_status(api: &Api<IndustrialPLC>, name: &str, status: IndustrialPLCStatus) -> Result<(), Error> {
    let patch = Patch::Merge(serde_json::json!({"status": status}));
    api.patch_status(name, &PatchParams::default(), &patch).await.map_err(Error::KubeError)?;
    Ok(())
}

pub fn error_policy(_plc: Arc<IndustrialPLC>, error: &Error, _ctx: Arc<Context>) -> Action {
    error!("Reconciliation failed: {:?}", error);
    Action::requeue(Duration::from_secs(5))
}

#[derive(Debug, thiserror::Error)]
pub enum Error {
    #[error("Kubernetes error: {0}")]
    KubeError(#[from] kube::Error),
    #[error("Serialization error: {0}")]
    SerializationError(#[from] serde_json::Error),
}
```

### 3.6 Main - `crates/operator/src/main.rs`

```rust
mod controller;
mod crd;
mod metrics;
mod plc_client;

use crate::controller::{error_policy, reconcile, Context};
use crate::crd::IndustrialPLC;
use crate::metrics::OperatorMetrics;
use axum::{routing::get, Router};
use kube::runtime::events::Reporter;
use kube::Client;
use prometheus::TextEncoder;
use std::net::SocketAddr;
use std::sync::Arc;
use tracing::{info, Level};
use tracing_subscriber::FmtSubscriber;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let subscriber = FmtSubscriber::builder().with_max_level(Level::INFO).finish();
    tracing::subscriber::set_global_default(subscriber)?;
    info!("Starting FabGitOps Operator...");
    
    let client = Client::try_default().await?;
    info!("Connected to Kubernetes cluster");
    
    let metrics = Arc::new(OperatorMetrics::new()?);
    info!("Metrics initialized");
    
    let ctx = Arc::new(Context {
        client: client.clone(),
        metrics: metrics.clone(),
        reporter: Reporter { controller: "fabgitops-operator".to_string(), instance: std::env::var("HOSTNAME").ok() },
    });
    
    let metrics_router = Router::new()
        .route("/metrics", get(metrics_handler))
        .route("/health", get(health_handler));
    let metrics_addr: SocketAddr = "0.0.0.0:8080".parse()?;
    let metrics_clone = metrics.clone();
    
    tokio::spawn(async move {
        info!("Starting metrics server on {}", metrics_addr);
        let app = metrics_router.layer(axum::Extension(metrics_clone));
        axum::serve(tokio::net::TcpListener::bind(metrics_addr).await.unwrap(), app).await.unwrap();
    });
    
    info!("Starting IndustrialPLC controller...");
    let plcs = Api::<IndustrialPLC>::all(client.clone());
    if let Err(e) = plcs.list(&Default::default()).await { info!("CRD may not exist yet: {}", e); }
    
    kube::runtime::Controller::new(plcs, Default::default())
        .run(reconcile, error_policy, ctx)
        .for_each(|res| async move {
            match res {
                Ok(o) => info!("Reconciled: {:?}", o),
                Err(e) => error!("Reconciliation error: {:?}", e),
            }
        }).await;
    Ok(())
}

async fn metrics_handler(axum::Extension(metrics): axum::Extension<Arc<OperatorMetrics>>) -> String {
    let encoder = TextEncoder::new();
    encoder.encode_to_string(&metrics.registry.gather()).unwrap_or_default()
}

async fn health_handler() -> &'static str { "OK" }
```

---

## 4. Phase 2: The Chaos Simulator

### 4.1 mock-plc Cargo.toml

```toml
[package]
name = "mock-plc"
version = "0.1.0"
edition = "2021"

[dependencies]
tokio = { workspace = true }
tokio-modbus = { version = "0.9", default-features = false, features = ["tcp", "server"] }
serde = { workspace = true }
serde_json = { workspace = true }
tracing = { workspace = true }
tracing-subscriber = { workspace = true }
anyhow = { workspace = true }
clap = { version = "4.4", features = ["derive"] }
rand = "0.8"
```

### 4.2 Chaos Module - `crates/mock-plc/src/chaos.rs`

```rust
use rand::Rng;
use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::Arc;
use tokio::time::{interval, Duration};
use tracing::{info, warn};

pub struct ChaosConfig {
    pub enabled: bool,
    pub interval_secs: u64,
    pub max_drift: u16,
}

pub struct ChaosEngine {
    config: ChaosConfig,
    running: Arc<AtomicBool>,
}

impl ChaosEngine {
    pub fn new(config: ChaosConfig) -> Self {
        Self { config, running: Arc::new(AtomicBool::new(false)) }
    }
    
    pub fn spawn(&self, register_value: Arc<std::sync::Mutex<u16>>) {
        if !self.config.enabled { return; }
        let running = self.running.clone();
        let interval_secs = self.config.interval_secs;
        running.store(true, Ordering::SeqCst);
        
        tokio::spawn(async move {
            let mut ticker = interval(Duration::from_secs(interval_secs));
            let mut rng = rand::thread_rng();
            while running.load(Ordering::SeqCst) {
                ticker.tick().await;
                let drift: i16 = rng.gen_range(-100..=100);
                if let Ok(mut value) = register_value.lock() {
                    let old_value = *value;
                    let new_value = (*value as i16 + drift).clamp(0, 65535) as u16;
                    *value = new_value;
                    warn!("ðŸŒ€ CHAOS DRIFT! {} â†’ {}", old_value, new_value);
                }
            }
        });
    }
}
```

### 4.3 Main - `crates/mock-plc/src/main.rs`

```rust
mod chaos;
mod server;

use crate::chaos::{ChaosConfig, ChaosEngine};
use crate::server::{start_server, PLCState};
use clap::Parser;
use std::sync::{Arc, Mutex};
use tracing::{info, Level};
use tracing_subscriber::FmtSubscriber;

#[derive(Parser, Debug)]
#[command(name = "mock-plc")]
#[command(about = "Mock PLC server with chaos mode")]
struct Args {
    #[arg(short, long, default_value = "0.0.0.0")]
    bind: String,
    #[arg(short, long, default_value = "5502")]
    port: u16,
    #[arg(short, long, default_value = "2500")]
    value: u16,
    #[arg(short, long, default_value = "4001")]
    register: u16,
    #[arg(long)]
    chaos: bool,
    #[arg(long, default_value = "10")]
    chaos_interval: u64,
    #[arg(long, default_value = "500")]
    max_drift: u16,
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    tracing_subscriber::fmt().with_max_level(Level::INFO).init();
    let args = Args::parse();
    info!("Mock PLC starting on {}:{}", args.bind, args.port);
    let state = Arc::new(Mutex::new(PLCState::new(args.value, args.register)));
    if args.chaos {
        let register_value = Arc::new(std::sync::Mutex::new(args.value));
        ChaosEngine::new(ChaosConfig { enabled: true, interval_secs: args.chaos_interval, max_drift: args.max_drift }).spawn(register_value);
    }
    start_server(&args.bind, args.port, state).await
}
```

---

## 5. Phase 3: The fabctl CLI Tool

### 5.1 fabctl Cargo.toml

```toml
[package]
name = "fabctl"
version = "0.1.0"
edition = "2021"

[[bin]]
name = "fabctl"
path = "src/main.rs"

[dependencies]
clap = { version = "4.4", features = ["derive", "cargo"] }
colored = "2.1"
comfy-table = "7.1"
kube = { version = "0.87", features = ["derive"] }
k8s-openapi = { version = "0.20", features = ["v1_28"] }
tokio = { workspace = true }
serde = { workspace = true }
serde_json = { workspace = true }
anyhow = { workspace = true }
tracing = { workspace = true }
tracing-subscriber = { workspace = true }
chrono = "0.4"
indicatif = "0.17"
operator = { path = "../operator" }
```

### 5.2 Output Module - `crates/fabctl/src/output.rs`

```rust
use operator::crd::IndustrialPLC;
use colored::*;
use comfy_table::{modifiers::UTF8_ROUND_CORNERS, presets::UTF8_FULL, Cell, Color, Table};

pub fn print_plc_table(plcs: &[IndustrialPLC]) {
    if plcs.is_empty() {
        println!("{}", "âš ï¸  No IndustrialPLC resources found".yellow());
        return;
    }
    let mut table = Table::new();
    table.load_preset(UTF8_FULL).apply_modifier(UTF8_ROUND_CORNERS);
    table.set_header(vec!["PLC Name", "Target", "Actual", "Status", "Drifts"]);
    
    for plc in plcs {
        let status = plc.status.as_ref();
        let synced = status.map(|s| s.in_sync).unwrap_or(false);
        let color = if synced { Color::Green } else { Color::Red };
        table.add_row(vec![
            Cell::new(plc.metadata.name.as_deref().unwrap_or("?")),
            Cell::new(plc.spec.target_value),
            Cell::new(status.and_then(|s| s.current_value).unwrap_or(0)),
            Cell::new(if synced { "SYNCED" } else { "DRIFT" }).fg(color),
            Cell::new(status.map(|s| s.drift_events).unwrap_or(0)),
        ]);
    }
    println!("{table}");
}
```

### 5.3 Main - `crates/fabctl/src/main.rs`

```rust
mod commands;
mod k8s_client;
mod output;

use crate::commands::*;
use crate::k8s_client::K8sClient;
use clap::Parser;
use colored::*;
use tracing::{error, Level};
use tracing_subscriber::FmtSubscriber;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let subscriber = FmtSubscriber::builder().with_max_level(Level::WARN).finish();
    tracing::subscriber::set_global_default(subscriber)?;
    let cli = Cli::parse();
    print_banner();
    let client = K8sClient::new().await?;
    
    let result = match &cli.command {
        Commands::GetStatus { name } => cmd_get_status(&client, &cli.namespace, name.as_deref(), cli.output).await,
        Commands::Describe { name } => cmd_describe(&client, &cli.namespace, name).await,
        Commands::Sync { name, force } => cmd_sync(&client, &cli.namespace, name, *force).await,
        Commands::Watch { interval } => cmd_watch(&client, &cli.namespace, *interval).await,
        Commands::List => cmd_list(&client, &cli.namespace).await,
        Commands::Version => cmd_version().await,
    };
    
    if let Err(ref e) = result {
        error!("{}", e);
        eprintln!("{} {}", "Error:".red().bold(), e);
        std::process::exit(1);
    }
    Ok(())
}

fn print_banner() {
    println!("{}", r#"
    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
    â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â•â• â–ˆâ–ˆâ•‘â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â•â•
    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
    â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â• â•šâ•â•â•â•â–ˆâ–ˆâ•‘
    â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘
    â•šâ•â•     â•šâ•â•  â•šâ•â•â•šâ•â•â•â•â•â•  â•šâ•â•â•â•â•â• â•šâ•â•   â•šâ•â•    â•šâ•â•â•â•â•â• â•šâ•â•     â•šâ•â•â•â•â•â•â•
    "#.bright_cyan().dimmed());
}
```

---

## 6. Phase 4: The Observability Stack

### 6.1 docker-compose.yml

```yaml
version: '3.8'
services:
  prometheus:
    image: prom/prometheus:v2.48.0
    ports: ["9090:9090"]
    volumes: ["./prometheus.yml:/etc/prometheus/prometheus.yml"]
  grafana:
    image: grafana/grafana:10.2.0
    ports: ["3000:3000"]
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=fabgitops
```

### 6.2 prometheus.yml

```yaml
global:
  scrape_interval: 5s
scrape_configs:
  - job_name: 'fabgitops-operator'
    static_configs:
      - targets: ['host.docker.internal:8080']
```

---

## 7. Phase 5: Demo & Deployment

### 7.1 Demo Script - `demo.sh`

```bash
#!/bin/bash
set -e
echo "Starting FabGitOps Demo..."
docker-compose up -d
./target/release/mock-plc --chaos --chaos-interval 10 &
helm install fabgitops ./charts/fabgitops
watch -n 1 ./target/release/fabctl get-status
```

---

## 8. Phase 6: Production Pipeline (CI/CD)

### 8.1 Helm Chart - `charts/fabgitops/Chart.yaml`

```yaml
apiVersion: v2
name: fabgitops
description: FabGitOps Industrial Operator
type: application
version: 0.1.0
appVersion: "1.0.0"
```

### 8.2 Helm Values - `charts/fabgitops/values.yaml`

```yaml
replicaCount: 1
image:
  repository: ghcr.io/yourusername/fabgitops-operator
  tag: "latest"
  pullPolicy: IfNotPresent
config:
  logLevel: "info"
  metricsPort: 8080
```

### 8.3 GitHub Actions - `.github/workflows/ci.yaml`

```yaml
name: CI/CD Pipeline
on: [push, pull_request]
env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  test:
    name: Lint & Test
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
      - run: cargo fmt -- --check
      - run: cargo clippy -- -D warnings
      - run: cargo test --workspace

  build-push:
    needs: test
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    permissions:
      packages: write
    steps:
      - uses: actions/checkout@v4
      - uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - uses: docker/build-push-action@v5
        with:
          context: .
          file: Dockerfile.operator
          push: true
          tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest

  e2e-test:
    needs: build-push
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: helm/kind-action@v1
      - run: helm install fabgitops ./charts/fabgitops
      - run: kubectl rollout status deployment/fabgitops --timeout=60s
```

### 8.4 ADR 001 - `docs/adr/001-why-rust-operator.md`

```markdown
# ADR 001: Use Rust for Kubernetes Operator

## Status: Accepted

## Decision
Use Rust (kube-rs) instead of Go.

## Reasoning
1. **Safety:** No Garbage Collection pauses (Stop-the-World) which disrupt timing loops.
2. **Correctness:** Compile-time memory safety prevents common runtime crashes.
```

### 8.5 ADR 002 - `docs/adr/002-modbus-tcp-strategy.md`

```markdown
# ADR 002: Modbus TCP Polling Strategy

## Status: Accepted

## Decision: Active Reconciliation Loop with Polling.

## Reasoning
PLCs are passive. We must poll registers every `pollIntervalSecs`.
To prevent network storms, we implement a "Circuit Breaker" that backs off after 3 failures.
```

---

## 9. Interview Talking Points

### The "Staff Engineer" Flex

**"It's not just code, it's a product."**
> "I packaged it with Helm so it can be deployed to any cluster with standard tooling."

**"I trust my pipeline."**
> "I have a GitHub Actions workflow that spins up a Kind cluster and verifies the operator before merging."

**"I document my trade-offs."**
> "Check the docs/adr folder. I documented why I chose Rust over Go."

---

## 10. Quick Start (Production Mode)

```bash
# Install via Helm
helm install fabgitops ./charts/fabgitops

# Verify release
helm list

# Check CI status
gh run list
```

---

*FabGitOps - The Infrastructure Layer of Your Industrial Cloud Stack*
